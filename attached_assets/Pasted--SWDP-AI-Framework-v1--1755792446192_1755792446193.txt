# SWDP AI Framework – 서비스 아키텍처 종합 정리 (v1)

> 본 문서는 제공된 키워드를 기반으로 **서비스 아키텍처**를 완전한 형태로 정리합니다. 각 레이어의 책임(Responsibility), 인터페이스(Interface), 데이터 모델(Data Model), 배포 토폴로지(Topology), 보안/운영(Ops) 기준, 장애 시나리오(Failure Modes), 테스트/릴리즈 전략까지 **생략 없이** 서술합니다.

---

## 0. 전체 개요 (Big Picture)

- **미션**: SWDP AI Framework는 DevOps → _NLOps_ 로 확장되는 **자연어 기반 업무 자동화 플랫폼**입니다.
- **핵심 축**: Presentation → Application → AI Persona → Data & Knowledge → AI & Integration → Operations & Security → Future Roadmap
- **중앙허브**: `Agentic Auto Orchestrator` 가 요청을 접수·분해·계획·실행하고, `Multi-Persona Engine`, `Context Engineering`, `Tool Calling` 과 협력하여 태스크를 완결합니다.
- **데이터 축**: `Knowledge Base / Vector / Graph / Raw VOC / Enterprise Connectors` 가 **RAG System**과 결합되어 **LLM API Gateway**를 통해 **Multi‑LLM** 추론으로 이어집니다.
- **품질관리**: `Feedback & Monitoring` + `A/B Testing`이 닫힌 루프를 형성하여 **LLM 품질·서비스 품질**을 지속 개선합니다.

---

## 1. 레이어드 아키텍처

### 1.1 Presentation Layer

**구성**: AI ChatOps UI, Admin Portal, Multi-Theme UI, VSCode Extension(PoC), AI Game & Learning Zone

**책임**

- 사용자 상호작용, 인증/인가 연동(RBAC), 세션/장치 식별, UI 내 도구 호출 패널, 결과 시각화(표/카드/타임라인)
- 멀티 테마, 접근성(ARIA), 국제화(i18n), 오프라인 캐시(선택)

**주요 인터페이스 (프런트 → 백엔드)**

- `POST /api/agent/execute` : 자연어 요청 → 오케스트레이션 실행
- `POST /api/context/session` : 대화 세션 생성/복구
- `GET /api/persona/list` : 사용 가능한 페르소나 프로필 목록
- `GET /api/kb/search?q=...` : KB 검색 미리보기(Top‑k)
- `GET /api/ab/config` : 실험 배정/변형 정보
- `POST /api/feedback` : 점수/코멘트/정오표 신고
- `GET /api/admin/metrics` : 관리자 대시보드 지표(권한 필요)

**프런트 기술 권장**

- Vue 2.7.x (현행 레거시 호환) + Vite 5.x, Axios, Pinia/Vuex, Playwright/E2E
- UI 컴포넌트: Tailwind, HeadlessUI, shadcn 포팅(선택)
- VSCode Extension: `vscode` API + Webview(Agent 패널)

---

### 1.2 Application Layer

**구성**: Agentic Auto Orchestrator, Multi‑Persona Engine, Context Engineering Engine, Prompt Management System, Multi‑LLM Orchestration, Tool Calling Framework

**책임**

- **오케스트레이션**: 계획(Planner) → 작업 단위(Task Graph) → 실행(Executor) → 관찰(Observer) → 수렴(Controller)
- **페르소나 라우팅**: 의도(Intent)·도메인·정책에 따라 7개 전문 페르소나 중 최적 선택
- **컨텍스트 엔지니어링**: 대화사·사용자 프로필·권한·KB 히트·테스트 변형을 결합한 **컨텍스트 패키징(Context Pack)**
- **프롬프트 관리**: 버전/릴리스/실험 분기, 안전규칙 삽입, 파라미터화(변수 템플릿)
- **멀티‑LLM**: 라우팅(규칙/모델성능/비용/지연), 폴백, 앙상블/재순위(Rerank)
- **툴 호출**: 스키마 선언(JSON Schema), 함수/에이전트·워크플로우 실행, 안전 가드

**핵심 인터페이스 (내부)**

- `Orchestrator.execute(request: UserRequest): OrchestrationResult`
- `PersonaRouter.route(context): PersonaPlan`
- `ContextPack.build(session, kbHits, graphHints, abVariant): PackedContext`
- `PromptRepo.get(key, version | tag): PromptTemplate`
- `LLMRouter.complete(modelHint, prompt, tools?): LLMResult`
- `ToolBus.invoke(toolName, args, authCtx): ToolResult`

---

### 1.3 AI 페르소나 모듈

**목록**: 주간보고 생성 봇, SWDP API 가이드봇, MENU TREE 가이드봇, SE 공지 봇, VOC Agent, Release Note 생성기, Economic Expense Helper

**공통 설계**

- Persona Manifest: 역할(Role), 도메인, 입력/출력 스키마, 정책(PII, 보안), 실패 폴백, 품질 규칙
- 행동 루프: `Perceive → Retrieve → Reason → Act → Reflect` (필요 시 도구 호출)
- 지표: 정답률/유용성/해결시간/도구호출수/비용

**예시 인터페이스**

- `POST /api/persona/weekly-report/generate`
- `POST /api/persona/voc/triage`
- `POST /api/persona/release-note/draft`

---

### 1.4 Data & Knowledge Layer

**구성**: Knowledge Base, Vector Store, Graph DB, Raw VOC Data Store, Enterprise Data Source Connector

**책임**

- 문서·코드·위키·티켓·로그 등 **원천 수집/정제/증강**
- 인덱싱(텍스트/표/코드/다중모달), 파티셔닝, 메타데이터 스키마(소스·보안등급·TTL)
- **Vector**: 임베딩/ANN 검색, 하이브리드 BM25+ANN, Rerank
- **Graph**: 엔터티/관계 추론, 근거 경로(Why-Path) 제공
- **Raw VOC**: 원본 보존, 정규화 스키마, 개인정보 토큰화/익명화
- 커넥터: Jira/Confluence/Git/DB/SharePoint/S3/SMTP 등 수집기

**주요 인터페이스**

- `POST /internal/ingest/doc` (메타 포함 배치)
- `POST /internal/index/vector` (임베딩/업서트)
- `POST /internal/index/graph` (노드/엣지 업서트)
- `GET /internal/search/hybrid?q=...&topk=...&filters=...`

---

### 1.5 AI & Integration Layer

**구성**: RAG System, LLM API Gateway, LLM Models, LLM API, Batch Data Preprocessor

**책임**

- **RAG 파이프라인**: 쿼리확장 → 검색 → 재순위 → 증거압축 → 컨텍스트패킹
- **LLM Gateway**: 업체/온프레 모델 추상화, 라우팅, 레이트리밋, 감사(Audit)
- **Batch Preprocessor**: 문서 청소/분할/NER/PII 마스킹/스냅샷 버저닝

**주요 인터페이스**

- `POST /internal/rag/query`
- `POST /internal/llm/complete` (모델: id|policy|routingHint)
- `POST /internal/batch/preprocess` (파이프라인 정의)

---

### 1.6 Operations & Security Layer

**구성**: Feedback & Monitoring System, A/B Testing Framework

**책임**

- **관측성**: 로그/트레이스/메트릭, 토큰·추론시간·히트율, 예산 얼럿
- **피드백**: 사용자 평점/수정·정오 데이터 수집, 라벨링 큐, 데이터 커브아웃
- **실험**: 트래픽 분할, 가설·변형 관리, 통계검정(Sequential/Fixed-horizon)
- **보안**: RBAC/ABAC, 비밀관리(KMS), API 서명, 감사추적, DLP/PII 정책

**주요 인터페이스**

- `POST /internal/feedback/event`
- `GET /internal/metrics/query`
- `POST /internal/ab/assign`

---

### 1.7 Future Roadmap

- VSCode Extension(정식화), CLI Tool, Proactive Alerting, AI‑Native DevOps Dashboard

---

## 2. 시스템 관계도 (Mermaid)

```mermaid
flowchart TB
  subgraph Presentation
    P1[AI ChatOps UI]
    P2[Admin Portal]
    P3[Multi-Theme UI]
    P4[VSCode Ext PoC]
    P5[AI Game & Learning]
  end
  subgraph Application
    A1[Agentic Orchestrator]
    A2[Multi-Persona Engine]
    A3[Context Engineering]
    A4[Prompt Mgmt]
    A5[Multi-LLM Orchestration]
    A6[Tool Calling Framework]
  end
  subgraph Persona
    AI1[Weekly Report Bot]
    AI2[SWDP API Guide Bot]
    AI3[Menu Tree Guide Bot]
    AI4[SE Notice Bot]
    AI5[VOC Agent]
    AI6[Release Note Generator]
    AI7[Economic Expense Helper]
  end
  subgraph Data & Knowledge
    D1[Knowledge Base]
    D2[Vector Store]
    D3[Graph DB]
    D4[Raw VOC Store]
    D5[Enterprise Connectors]
  end
  subgraph AI & Integration
    I1[RAG System]
    I2[LLM API Gateway]
    I3[LLM Models]
    I4[LLM API]
    I5[Batch Preprocessor]
  end
  subgraph Ops & Security
    O1[Feedback/Monitoring]
    O2[A/B Testing]
  end
  subgraph Roadmap
    F1[VSCode Ext]
    F2[CLI Tool]
    F3[Proactive Alerts]
    F4[AI DevOps Dashboard]
  end

  P1 & P2 & P3 & P4 & P5 --> A1
  A1 --> A2 & A3 & A4 & A5 & A6
  A2 --> AI1 & AI2 & AI3 & AI4 & AI5 & AI6 & AI7
  AI1 & AI2 & AI3 & AI4 & AI5 & AI6 & AI7 --> D1 & D2 & D3 & D4 & D5
  D1 & D2 & D3 & D4 & D5 --> I1 & I2 & I3 & I4 & I5
  I1 & I2 & I3 & I4 & I5 --> O1 & O2
  O1 & O2 --> F1 & F2 & F3 & F4
  O1 -.-> A2
  O2 -.-> A4
```

---

## 3. 핵심 유스케이스 시퀀스

### 3.1 ChatOps 질의 → 주간보고 초안 생성

1. UI가 `POST /api/agent/execute` 로 사용자 질의 전송
2. Orchestrator가 Intent(보고 생성) 식별 → PersonaRouter가 `Weekly Report Bot` 선택
3. ContextPack이 최근 스프린트 이력, Jira, Git 로그, 릴리스 태그를 KB/Vector/Graph에서 검색하여 구성
4. PromptMgmt가 페르소나별 템플릿과 정책 프롬프트를 삽입
5. LLMRouter가 모델/비용/지연/BudgetPolicy를 고려해 모델 선택(예: 온프레 Llama, 외부 GPT 폴백)
6. 필요 시 ToolBus가 `GitLogTool`, `JiraQueryTool` 호출하여 근거 보강
7. 응답 생성 후 Evidence(인용), TraceID, TokenUsage와 함께 반환 → UI 랜더링
8. 사용자가 피드백 제출 → Feedback 수집 → A/B 프레임워크에 반영

### 3.2 VOC 티켓 자동 분류·요약·우선순위 설정

1. UI/Webhook → `VOC Agent` 호출
2. RAG가 VOC 원문 + 고객 메타를 검색/정규화
3. LLM 분류/요약 → 우선순위/팀 라우팅 제안 → API로 티켓 시스템 업데이트
4. 결과/메트릭 로깅, 오판 사례는 라벨링 큐로 전송

### 3.3 릴리스 노트 생성

- Git 태그 범위 입력 → Diff 요약 → Breaking Changes/Risk/테스트 포인트 자동 도출 → Admin 승인 → 게시/공지 봇 연동

---

## 4. 데이터 모델 & 스키마

### 4.1 공통 메타데이터

```json
{
  "source": "jira|git|wiki|mail|sharepoint|db|s3",
  "security_tier": "public|internal|restricted",
  "owner": "team-id",
  "created_at": "ISO8601",
  "updated_at": "ISO8601",
  "ttl_days": 180,
  "tags": ["release", "voc", "api", "se-notice"],
  "hash": "content-sha256"
}
```

### 4.2 Vector 인덱스 엔트리

```json
{
  "doc_id": "uuid",
  "chunk_id": "uuid",
  "embedding": "float32[1536|3072]",
  "text": "...",
  "metadata": {
    "source": "...",
    "security_tier": "internal",
    "route_hints": ["weekly-report"]
  }
}
```

### 4.3 Graph 스키마(개략)

- **노드**: `Service`, `Repo`, `Issue`, `Release`, `Persona`, `User`
- **엣지**: `DEPENDS_ON`, `OWNED_BY`, `MENTIONS`, `FIXED_IN`, `ROUTES_TO`

### 4.4 VOC Raw/Normalized

```json
{
  "ticket_id": "string",
  "channel": "email|web|phone",
  "customer_tier": "A|B|C",
  "raw_text": "...",
  "pii_masked_text": "...",
  "intent": "refund|bug|request|question",
  "priority": "P0|P1|P2|P3",
  "assignee_team": "SE|Dev|Ops",
  "status": "new|triaged|in-progress|resolved",
  "evidence": [{ "kb_doc": "uuid", "score": 0.73 }]
}
```

---

## 5. API 설계 (대표 예시)

### 5.1 Orchestrator 실행

**Request**

```http
POST /api/agent/execute
Content-Type: application/json
```

```json
{
  "session_id": "sess-123",
  "user": { "id": "u-001", "roles": ["dev", "se"], "locale": "ko-KR" },
  "input": {
    "text": "이번 주간보고 초안 만들어줘. 기준은 v2.3 릴리스 이후.",
    "attachments": [],
    "persona_hint": "weekly-report"
  },
  "ab": { "exp_keys": ["prompt.v7", "rerank.on"] }
}
```

**Response**

```json
{
  "trace_id": "tr-9f...",
  "persona": "weekly-report",
  "outputs": [{ "type": "markdown", "content": "## 주간보고 초안 ..." }],
  "evidence": [{ "doc_id": "...", "snippet": "...", "score": 0.82 }],
  "usage": { "input_tokens": 2354, "output_tokens": 812, "latency_ms": 3820 }
}
```

### 5.2 KB 하이브리드 검색

```http
GET /api/kb/search?q=release%20note&topk=5&filters=security_tier:internal
```

**Response**

```json
{
  "hits": [
    {
      "doc_id": "...",
      "title": "Release v2.3",
      "score": 0.74,
      "highlights": ["..."]
    }
  ]
}
```

### 5.3 피드백 수집

```http
POST /api/feedback
```

```json
{
  "trace_id": "tr-9f...",
  "rating": 4,
  "comment": "근거가 좋아요. 다음엔 성능 수치 포함 부탁.",
  "labels": ["useful", "minor-miss"],
  "proposed_fix": "성과지표 섹션 추가"
}
```

---

## 6. 배포 토폴로지 & 인프라

### 6.1 권장 토폴로지 (On‑prem / Hybrid)

- **Kubernetes 네임스페이스**

  - `swdp-ui`: 프런트 정적 자산, CDN/Ingress
  - `swdp-app`: Orchestrator, Persona, Context, Prompt, ToolBus (HorizontalPodAutoscaler)
  - `swdp-ai`: RAG, LLM Gateway, Embedding, Rerank, Batch Preprocess
  - `swdp-data`: Vector(DB), Graph(DB), KB(Object Storage), Connectors
  - `swdp-ops`: Observability(ELK/EFK, Prometheus/Grafana), A/B, Feedback API

- **스토리지**:

  - Vector: pgvector/Weaviate/FAISS + WAL/스냅샷
  - Graph: Neo4j/JanusGraph
  - KB: S3 호환(Object), 버전 적용

- **네트워크**: Istio/Service Mesh(선택), mTLS, JWT/OIDC, egress 정책
- **GPU**: 추론 노드 풀 분리, 스케줄러 톤(taints/tolerations)

### 6.2 확장성/가용성

- **Scale-out 우선**: Stateless 서비스(HPA), 배치 파이프라인은 큐 기반(Argo/KEDA)
- **SLO**: P95 응답 5s, 가용성 99.9%, 지식 동기 지연 < 10분(업무 시간)
- **캐시**: Retrieval Cache(쿼리→증거), Prompt Compile Cache

---

## 7. 보안, 규정 준수, 데이터 보호

- **인증/인가**: OIDC(SAML 브리지), RBAC/ABAC(리소스/페르소나/툴 레벨)
- **비밀 관리**: Vault/KMS, Secret Zero(Init), 키 로테이션 90일
- **데이터 분리**: `security_tier` 기준 정책; 프롬프트/컨텍스트 DLP 룰(PII 마스킹)
- **감사**: 모든 LLM 호출에 `trace_id`, 입력/출력 요약 로그, 도구 호출 이력
- **규제**: 모델/데이터 경계(온프레 우선, 외부 호출 시 정책+마스킹), 보존/삭제 정책

---

## 8. 관측성, 피드백, A/B 실험

### 8.1 관측 지표(Metrics)

- **성능**: 토큰/초, 지연, 오류율, 검색 Hit\@k, Rerank NDCG
- **품질**: 사용자 평점, 편집율(Edit distance), 해결률, 페르소나별 CSAT
- **비용**: 추론비용/요청, 월간 예산, 모델별 단가 기여

### 8.2 피드백 파이프라인

- UI → Feedback API → 큐 → 라벨링 콘솔 → 데이터 큐레이션 → 재학습/프롬프트 튜닝

### 8.3 A/B 프레임워크

- 배정: 사용자/세션 기반 Consistent Hashing
- 실험 유닛: 프롬프트 버전, 모델 라우팅, RAG 파라미터(topk, rerank on/off)
- 통계: 최소 표본 크기, MDE 설정, Sequential 검정(권장) or 고정 지평선

---

## 9. Tool Calling Framework 설계

- **선언**: OpenAPI/JSON Schema로 함수 시그니처 정의
- **실행**: 샌드박스/권한 컨텍스트(사용자/역할/리소스), 타임아웃/리트라이/회로차단기
- **예시 스키마**

```json
{
  "name": "query_jira",
  "description": "Jira 이슈 검색",
  "parameters": {
    "type": "object",
    "properties": {
      "jql": { "type": "string" },
      "fields": { "type": "array", "items": { "type": "string" } },
      "max": { "type": "integer", "default": 20 }
    },
    "required": ["jql"]
  },
  "auth": "as-user|as-service"
}
```

---

## 10. Prompt Management 체계

- **버전**: `prompt://persona/weekly-report@v7` 처럼 주소화
- **구성**: System(정책) + Developer(지침) + Task(요청) + Safety(금칙어/PII 규칙)
- **릴리즈**: 서명된 번들(Checksum), 롤백 포인트, A/B 라벨
- **거버넌스**: PR 리뷰, 정량지표 기준 합격 시 배포

---

## 11. 실패 모드 & 폴백 전략

- **LLM 타임아웃/과금 제한**: 대체 모델/요약 모드 폴백, 캐시된 응답 반환
- **검색 실패**: 쿼리 재작성(Query Expansion), 소스 변경, 최소 응답 전략
- **툴 실패**: 회로 차단 → 대체 경로(수동 가이드) → 사용자 알림
- **KB 신뢰도 낮음**: 증거 점수/가중치 기준 Fail-safe 응답(명시적 한계 선언)

---

## 12. 테스트 전략

- **프롬프트 유닛테스트**: 합성 데이터/골든셋, 실패 케이스 수집
- **회귀/성능**: 시나리오 리플레이, 토큰/지연 추적
- **E2E**: Playwright (UI) + Contract 테스트(백엔드)
- **카나리**: 트래픽 5% → 25% → 100%, 자동 롤백 조건

---

## 13. 운영 플레이북 (요약 아닌 상세 지침)

- **릴리즈**: Prompt 번들 → 앱 이미지 → 마이그레이션 → 카나리 → 실험 시작
- **온콜**: 알람(오류율/지연/비용 폭주), 1차 대응 절차, 에스컬레이션 경로
- **데이터 동기**: 주간 전량 재인덱싱 + 실시간 증분, 실패시 리트라이 백오프
- **성능 튜닝**: topk, chunk size, rerank 스위치, 모델 라우팅 테이블 핫패치

---

## 14. 역할·권한 모델 (예시)

- **Role**: `admin`, `se`, `dev`, `viewer`
- **Policy**: 페르소나 호출/툴 범위/데이터 보안등급 접근권
- **감사 포맷**

```json
{
  "trace_id": "...",
  "actor": "u-001",
  "persona": "voc-agent",
  "tools": ["query_jira"],
  "data_tier": "internal",
  "time": "ISO8601"
}
```

---

## 15. 로드맵 연계 상세

- **VSCode Extension**: 코드 변경 요약/테스트 생성/리뷰 코멘트, 로컬 컨텍스트 인덱싱
- **CLI**: `swdp agent run -p weekly-report -i input.json`
- **Proactive Alerts**: 릴리스 위험 감지, VOC 급증 감지, 모델 품질 하락 얼럿
- **AI DevOps Dashboard**: 품질·비용·생산성 KPI, 페르소나별 성과 보드

---

## 16. 아키텍처 결정 기록(ADR) 권고 항목

1. Vector/Graph 이중 인덱싱 채택 이유
2. 온프레 우선 + 외부 LLM 폴백 기준(PII, 성능)
3. 프롬프트 버저닝 방식과 실험 거버넌스
4. ToolBus 권한 위임 정책(as‑user vs as‑service)
5. 캐시/재현성(Traceable Context Pack) 보장 설계

---

## 17. 제공 산출물 체크리스트

- [ ] OpenAPI 스펙(외부/내부)
- [ ] Persona Manifest 7종
- [ ] Prompt 번들 v1 (System/Dev/Task/Safety 구분)
- [ ] RAG 파이프라인 파라미터 기본값(topk, chunk, rerank)
- [ ] 데이터 커넥터 목록/주기/보안등급 매핑표
- [ ] 모니터링 대시보드 쿼리(토큰/지연/Hit\@k/비용)
- [ ] A/B 실험 설계 문서 + KPI 정의
- [ ] 온콜 런북 & 장애 대응 툴킷

---

## 18. 다음 단계(실행 로드맵)

1. 최소기능(MVP): Orchestrator, Persona 두 종(Weekly/VOC), RAG 기본, LLM Gateway, KB Ingest
2. 운영 패스: 관측/피드백/AB 최소선, RBAC 1단계
3. 확장: Release Note/Expense Helper 추가, Graph 인덱스 도입, VSCode Ext α
4. 최적화: 모델 라우팅 룰·캐시, 비용 가드, 실험 자동화

---

> 본 문서는 그대로 **설계 기준선(Baseline)** 역할을 하며, 이후 이슈/PR/ADR로 세부를 고도화합니다.

백앤드 구성 기술 아키텍처도 설명해줄게 말로만 풀어쓰면돼

일단 주간보고 생성을 위해서 JIRA 정보를 JQL 명령으로 일주일 베이스로 데이터를 모두 가져와서 필요 데이터만 json 파싱을 수행함. Update와 Create 표현 규칙에 따라서 Prompt 구성 LLM 프롬프트는 수차례의 실험과 일종의 디스틸레이션 기법으로 Claude Opus 4.1 , GPT 5의 답변 양식을 기반으로 동일 답변 수준이 나올 수 있는 방식으로 A/B 테스트를 진행해서 답변 일관성을 유지함
JIRA 데이터 + SWDP에게 권한이 있는 과제 정보 기반으로 사용자로 부터 입력받은 주간보고 양식을 Fewshot data로 활용하여 주간보고 생성 (없으면 default로 설정한 주간보고 양식으로 설정)

CA경비처리 도우미 페르소나에 사용된 기술은 LLM LLAMA 4 Maverick 모델을 활용한 멀티모달 이미지 분석을 통한 영수증 자동 분석 시스템을 구축함 사용자 프롬프트와 이미지 데이터를 Base64로 디코딩 이후 llama4를 통해서 이미지 분석 (https 이슈로 최대 이미지 5개) 분석 데이터를 json으로 직렬화하여 ai chatops에서 프리젠테이션 레이어에서 사용자가 수정가능한 form 형태로 제공 사용자는 해당 데이터에 피드백 또는 검수 완료하고 저장 버튼을 누름
저장 수행된 데이터는 원래라면 confluence wiki 지정된 CA 페이지에 업로드 해줘야하지만 현재 Confluence wiki 사용 문제(write 권한 x read도 2분에 1회 호출만 가능)로 github wiki 또는 jira 로 데이터 저장 고려중 기술적으로 poc 확인했으나 적용 단계 고민 중

Auto Agentic Persona 서비스는 사용자 질의에 맞는 등록된 persona를 LLM을 통해서 자동 선택해서 답변하는 오케스트레이션 에이전트 서비스이며 A/B테스트 결과 동작 정확도 95%이상 확보했음 단, LLM 요청을 2회 이상 수행해야 하는 부분에서 성능 이슈와 1분에 호출할 수 있는 내부망 LLM 호출 제한으로 인해서 사용성 검토 중. Agentic 서비스 구축과 실제 운영단계 적용에 괴리가 있음 기술적인 부분보다 운영적인 문제가 더 큼

SWDP API 서비스는 SWDP OPEN API는 개발과 동시에 Swagger form으로 github 지정된 페이지에 배포되고 있으며 SWDP API 가이드 봇은 요청과 동시에 해당 API 데이터를 모두 가져와서 RAG로 활용하여 답변을 수행하는 서비스

SWDP MENU TREE BOT은 SWDP 전체에 산재되어 있는 수많은 메뉴와 서비스에 대한 가이드북을 RAG로 하여 사용자 질의에 맞는 답변을 수행함 + 여기에는 사용자 정보를 기반으로 SWDP DB의 사용자 프로젝트 데이터를 함께 RAG로 연동하여 내 과제 확인하는 방법과 같은 개인화된 도메인 서비스가 가능하도록 구현되어 있음

SE SWDP 팀 공지 봇은 주기적으로 또는 비정기적으로 공지되는 주요 이슈들을 트래킹하여 요약 정보와 해당 공지의 URL를 구조화된 json으로 보관하고 있다가 사용자 질의에 맞게 관련 정보와 실제 데이터 위치를 제공하는 서비스 모든 데이터를 직접 보여주는 형식이 아닌, 정확도를 위해 실제 데이터가 있는 URL을 적재적소에 제공하는 서비스 페르소나

VOC 봇은 VOC Agent 서비스를 위해서 구축된 구조화된 FAQ를 RAG로 하여 답변하는 봇으로 VOC를 등록하기전에 간단한 질의와 문제에 대한 기존 이슈를 확인할 수 있도록 서비스 기획 중이며 현재 사용자들이 혼용사용하고 있는 용어에 대한 분류 문제 (예를들면 각 서비스에서 "프로젝트"라는 용어를 사용하고 있으므로 카테고리가 지정되지 않으면 TASTY 프로젝트인지 DoBEE 프로젝트인지 GIT 프로젝트를 의미하는지 판단할 수 없어서 할루시네이션이 빈번하게 발생하는 문제가 있음 카테고리를 먼저 선택하고 질문을 하는 방식 또는 답변에 필요한 인풋이 모두 제공되지 않는 경우 재질문하는 방식으로 시스템 업데이트 진행 중

위의 서비스는 모두 Multi LLM 전략으로 LLAMA Maverick Gemma3 Guass O Think 등 다양한 LLM을 병렬로 호출하여 역할에 맞는 동작을 수행시키고 있으며 성능적인 문제보다 사용량 제약에 따른 Context engineering이 많이 포함되어있음
